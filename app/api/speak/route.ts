import { Message } from 'ai';
import { NextRequest, NextResponse } from 'next/server';

import { deepgramTts } from './deepgram';
import { azureTts } from './azure';
import { elevenlabsTts } from './elevenlabs';
import { TtsApi } from './types';
import { makeTextSpeakable } from './utils';

import { voices } from '@/app/context/Voices';

const ttsApis: Record<string, TtsApi> = {
  deepgram: deepgramTts,
  azure: azureTts,
  elevenlabs: elevenlabsTts,
};

/**
 * Return a stream from the API
 * @param {NextRequest} req - The HTTP request
 * @returns {Promise<NextResponse>} A NextResponse with the streamable response
 */
export async function POST(req: NextRequest) {
  const url = req.url; // gotta use the request object to invalidate the cache every request :vomit:
  const message: Message = await req.json();
  const start = Date.now();

  const model = req.nextUrl.searchParams.get('model') ?? 'aura-asteria-en';
  const { ttsProvider, voiceId } = voices[model];

  try {
    const text = makeTextSpeakable(message.content);

    const response = await ttsApis[ttsProvider]({
      text,
      referrerUrl: url,
      voiceId,
      model,
    });

    if (!response?.body) {
      return new NextResponse('Unable to get response from API.', {
        status: 500,
      });
    }

    console.info(`[${ttsProvider}] Text to speech successfully generated by`);

    const headers = new Headers();
    headers.set('X-DG-Latency', `${Date.now() - start}`);
    headers.set('Content-Type', 'audio/mp3');

    return new NextResponse(response.body, {
      headers,
    });
  } catch (error) {
    return new NextResponse(error || error?.message, { status: 500 });
  }
}
